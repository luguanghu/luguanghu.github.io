<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="检测对象类型的几种方式： typeof 最常用 对正则表达式使用typeof可能会反回‘function’‘undefined’— undefined‘boolean’  — 布尔值‘string’   — 字符串‘number’   — 数字‘object’   — 对象或null‘function’ — 函数 instanceof 判断是否属于某个对象的实例，两个对象必须在同一个全局作用域中">
<meta property="og:type" content="website">
<meta property="og:title" content="高级函数">
<meta property="og:url" content="http://yoursite.com/high-level-func/index.html">
<meta property="og:site_name" content="luhu">
<meta property="og:description" content="检测对象类型的几种方式： typeof 最常用 对正则表达式使用typeof可能会反回‘function’‘undefined’— undefined‘boolean’  — 布尔值‘string’   — 字符串‘number’   — 数字‘object’   — 对象或null‘function’ — 函数 instanceof 判断是否属于某个对象的实例，两个对象必须在同一个全局作用域中">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-07-30T09:30:49.682Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="高级函数">
<meta name="twitter:description" content="检测对象类型的几种方式： typeof 最常用 对正则表达式使用typeof可能会反回‘function’‘undefined’— undefined‘boolean’  — 布尔值‘string’   — 字符串‘number’   — 数字‘object’   — 对象或null‘function’ — 函数 instanceof 判断是否属于某个对象的实例，两个对象必须在同一个全局作用域中">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/high-level-func/">





  <title>高级函数 | luhu</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">luhu</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">前端开发</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    
    
    
    <div class="post-block page">
      <header class="post-header">

	<h1 class="post-title" itemprop="name headline">高级函数</h1>



</header>

      
      
      
      <div class="post-body">
        
        
          <h4 id="检测对象类型的几种方式："><a href="#检测对象类型的几种方式：" class="headerlink" title="检测对象类型的几种方式："></a>检测对象类型的几种方式：</h4><ol>
<li>typeof 最常用 对正则表达式使用typeof可能会反回‘function’<br>‘undefined’— undefined<br>‘boolean’  — 布尔值<br>‘string’   — 字符串<br>‘number’   — 数字<br>‘object’   — 对象或null<br>‘function’ — 函数</li>
<li>instanceof 判断是否属于某个对象的实例，两个对象必须在同一个全局作用域中</li>
<li>constructor 判断  someobj.constructor == Array/Object/Boolean…</li>
<li>Object.prototype.toString.call()，最为安全的方法，该方法不能检测非原生构造函数的函数名，开发人员定义的任何构造函数都将返回[object,Object],可以检测正则和原生对象<br>Object.prototype.toString.call(somejson) == “[object JSON]”;// 检测是否为原生json</li>
</ol>
<h4 id="创建作用域安全的对象"><a href="#创建作用域安全的对象" class="headerlink" title="创建作用域安全的对象"></a>创建作用域安全的对象</h4><p>为了避免调用构造函数未使用new操作符导致全局污染或意外错误，应该创建作用域安全的构造函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function F(arg1,arg2)&#123;</span><br><span class="line">    if(this instanceof F)&#123;</span><br><span class="line">        this.prop1 = arg1;</span><br><span class="line">        this.prop2 = arg2;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return new F(arg1,arg2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var instance1 = new F(&apos;a&apos;,&apos;b&apos;);</span><br><span class="line">var instance2 = F(&apos;a&apos;,&apos;b&apos;);</span><br></pre></td></tr></table></figure></p>
<p>但这样会有一个问题，当另一个构造函数想要通过借用该构造函数实现继承时，由于this不同，会导致继承势失败<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Child(arg)&#123;</span><br><span class="line">    F.call(this,&apos;c&apos;);</span><br><span class="line">    this.prop3 = arg;</span><br><span class="line">&#125;</span><br><span class="line">var child = new Child(&apos;d&apos;);</span><br><span class="line">console.log(child.prop1); // undefined 并不能继承到prop1</span><br></pre></td></tr></table></figure></p>
<p>解决办法是结合原型链继承<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Child(arg)&#123;</span><br><span class="line">    F.call(this,&apos;c&apos;);</span><br><span class="line">    this.prop3 = arg;</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = new F();// 使得child也是F的一个实例</span><br><span class="line">var child = new Child(&apos;d&apos;);</span><br><span class="line">console.log(child.prop1); // c</span><br></pre></td></tr></table></figure></p>
<h4 id="惰性载入函数"><a href="#惰性载入函数" class="headerlink" title="惰性载入函数"></a>惰性载入函数</h4><p>应用：避免一些不需要重复的逻辑的重复执行，优化性能<br>实现方式：a 调用函数时通过条件判断用新函数覆盖原来的函数；b 利用立即执行函数内部的条件判断，返回新的函数声明<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// 方式a</span><br><span class="line">function createXHR()&#123;</span><br><span class="line">    if(typeof XMLHttpRequest != &apos;undefined&apos;)&#123;</span><br><span class="line">        createXHR = function()&#123;</span><br><span class="line">            return new XMLHttpRequest();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if(typeof ActiveObject != &apos;undefined&apos;)&#123;</span><br><span class="line">        createXHR = function()&#123;</span><br><span class="line">            return new ActiveObject(&apos;Microsoft.XMLHTTP&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        createXHR = function()&#123;</span><br><span class="line">            throw new Error(&apos;no XHR support!&apos;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return createXHR();</span><br><span class="line">&#125;</span><br><span class="line">// 方式b</span><br><span class="line">function createXHR = (function()&#123;</span><br><span class="line">    if(typeof XMLHttpRequest != &apos;undefined&apos;)&#123;</span><br><span class="line">        return function()&#123;</span><br><span class="line">            return new XMLHttpRequest();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if(typeof ActiveObject != &apos;undefined&apos;)&#123;</span><br><span class="line">        return function()&#123;</span><br><span class="line">            return new ActiveObject(&apos;Microsoft.XMLHTTP&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return function()&#123;</span><br><span class="line">            throw new Error(&apos;no XHR support!&apos;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></p>
<h4 id="柯里化函数"><a href="#柯里化函数" class="headerlink" title="柯里化函数"></a>柯里化函数</h4><p>柯里化作用：复用参数，延迟执行<br>偏函数：固定函数的某个部分，通过传入参数或方法返回一个新的函数来处理余下的参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function isType(type)&#123;</span><br><span class="line">    return function(obj)&#123;</span><br><span class="line">        return Object.prototype.toString.call(obj) === &quot;[object `$&#123;type&#125;`]&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let isString = isType(&apos;String&apos;);</span><br><span class="line">let isArray = isType(&apos;Array&apos;);</span><br><span class="line">console.log(isString(&apos;ssss&apos;));// true</span><br></pre></td></tr></table></figure></p>
<p>柯里化函数：把一个有n个参数的函数转化为n个只有1个参数的函数<br>通用柯里化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// es5</span><br><span class="line">function curry(fn)&#123;</span><br><span class="line">    var args = [].prototype.slice.call(arguments,1);</span><br><span class="line">    return function()&#123;</span><br><span class="line">        var innerArgs = [].prototype.slice.call(arguments);</span><br><span class="line">        var finalArgs = args.concat(innerArgs);</span><br><span class="line">        if(finalArgs.length&lt;fn.length)&#123;</span><br><span class="line">            return curry.call(null,fn,finalArgs);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return fn.apply(null,finalArgs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// es6</span><br><span class="line">const curry = (fn,...rest1)=&gt;(...rest2)=&gt;</span><br><span class="line">rest1.concat(rest2).length&lt;fn.length?</span><br><span class="line">        curry.apply(null,fn,rest1.concat(rest2))</span><br><span class="line">        :fn.apply(null,rest1.concat(rest2));</span><br></pre></td></tr></table></figure></p>
<h4 id="定时器的应用"><a href="#定时器的应用" class="headerlink" title="定时器的应用"></a>定时器的应用</h4><p>每个浏览器窗口，标签页，frame都有各自的代码执行队列，如果跨用定时器可能会导致竞争条件。</p>
<p>js运行于单线程的环境中，定时器仅仅是计划代码在未来的某个时间执行，执行时机是不能保证的，定时器在特定的时间过去后将代码插入队列，并不意味着代码能立即被执行。<br>settimeout（func,time）如果不加入time参数,浏览器会自动分配时间，IE Firefox一般在100ms左右，其他在10ms左右<br>setInterval()时，仅在当前队列中没有实例时才将代码插入队列，确保了定时器将代码插入队列的最小间隔时间为指定时间。这样会导致两个问题：1 某些间隔会被跳过 2 多个定时器代码执行时间间隔可能会比预期小，为了解决这个问题，使用setTimeout的链式调用,确保不会有任何缺失的间隔，也能避免连续运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function()&#123;</span><br><span class="line">    // do some thing</span><br><span class="line">    setTimeout(arguments.callee,interval);</span><br><span class="line">&#125;,interval)</span><br></pre></td></tr></table></figure></p>
<p>数组分块技术可防止浏览器阻塞：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function trunk(array,process,context)&#123;</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">    var item = array.shift();</span><br><span class="line">    prosees.call(context,item);</span><br><span class="line">    if(array.length)&#123;</span><br><span class="line">        setTimeout(arguments.callee,delaytime)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,delaytime)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="函数节流-throttle"><a href="#函数节流-throttle" class="headerlink" title="函数节流 throttle"></a>函数节流 throttle</h4><p>不管调用有多频繁，调用在规定的时间间隔内只会执行一次<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function throttle(fn, delay) &#123;</span><br><span class="line">    let startTime = Date.now();</span><br><span class="line">    return function()&#123;</span><br><span class="line">        let context = this;</span><br><span class="line">        let argus = arguments;</span><br><span class="line">        let now = Date.now();</span><br><span class="line">        if(now-startTime&gt;=delay)&#123;</span><br><span class="line">            fn.apply(context,argus);</span><br><span class="line">            startTime = now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="防抖函数-debonuce"><a href="#防抖函数-debonuce" class="headerlink" title="防抖函数 debonuce"></a>防抖函数 debonuce</h4><p>操作后延迟执行，在规定的时间内若干个调用合并为一次<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function throttle(fn, delay) &#123;</span><br><span class="line">    let timer = null;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        let args= arguments;</span><br><span class="line">        let context = this;</span><br><span class="line">        timer &amp;&amp; clearTimeout(timer);</span><br><span class="line">        timer = setTimeout(function()&#123;</span><br><span class="line">            fn.apply(context,argus);</span><br><span class="line">        &#125;,delay)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h4><p>观察者模式的自定义事件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">function EventTarget()&#123;</span><br><span class="line">    thius.handlers = &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line">EventTarget.prototype = &#123;</span><br><span class="line">    constructor:EventTarget,</span><br><span class="line">    addHandler:function(type,handler)&#123;</span><br><span class="line">        if(typeof this.handlers[type] == &quot;undefined&quot;)&#123;</span><br><span class="line">            this.handlers[type] = []</span><br><span class="line">        &#125;</span><br><span class="line">        this.handlers[type].push(handler);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;,</span><br><span class="line">    removeHandler:function(type,handler)&#123;</span><br><span class="line">        if(this.handlers[type] instanceof Array)&#123;</span><br><span class="line">            for(let i=0;i&lt;this.handlers[type].length;i++)&#123;</span><br><span class="line">                if(this.handlers[type][i] === handler)&#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            this.handlers[type].splice(i,1);</span><br><span class="line">        &#125;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;,</span><br><span class="line">    trigger:function(type)&#123;</span><br><span class="line">        let context = this;</span><br><span class="line">        let argus = Array.prototype.slice.call(arguments,1);</span><br><span class="line">        if(this.handlers[type] instanceof Array)&#123;</span><br><span class="line">            this.handlers[type].forEach(function(item)&#123;</span><br><span class="line">                item.apply(context,argus);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function hanleMsg(event)&#123;</span><br><span class="line">    console.log(event);</span><br><span class="line">&#125;</span><br><span class="line">var target = new EventTarget();</span><br><span class="line">target.addHandler(&apos;massge&apos;,handleMsg);</span><br><span class="line">target.trigger(&apos;hello&apos;);</span><br><span class="line">target.removeHandler(&apos;massage&apos;,handleMsg);</span><br></pre></td></tr></table></figure></p>
<h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><p>回调函数 =&gt; 事件监听（发布订阅者模式） =&gt; promise =&gt;  generator函数 =&gt;  asyc/await</p>
<p>1 回调函数（回调地狱问题，以及回调函数之外无法通过trycatch捕获异常）；<br>Tips: 为什么异步代码回调函数中的异常无法被最外层的try/catch语句捕获?<br>异步调用一般分为两个阶段，提交请求和处理结果，这两个阶段之间有事件循环的调用，它们属于两个不同的事件循环(tick)，彼此没有关联。<br>异步调用一般以传入callback的方式来指定异步操作完成后要执行的动作。而异步调用本体和callback属于不同的事件循环。<br>try/catch语句只能捕获当次事件循环的异常，对callback无能为力。</p>
<p>2 事件监听（适合高度解耦的场景）</p>
<p>3 promise函数 解决回调地狱<br>tips： promise.prototype.catch是 promise.prototype.then(null,rejection)的别名<br>4 generator函数<br>5 asyc/await 异步终极形式</p>
<h4 id="深度克隆"><a href="#深度克隆" class="headerlink" title="深度克隆"></a>深度克隆</h4><p>js的数据类型分为两大类：<br>原始类型包括：数字 布尔值 字符串 null undefined  —–存储的是对象的原始数据<br>对象类型包括：函数（一等对象），数组（键值的有序集合）—–存储的是对象的引用</p>
<p>浅度克隆：原始类型为值传递，引用类型为引用传递；<br>深度克隆：所有对象均完全复制，与原对象完全脱离；</p>
<p>1 JSON.parse(JSON.stringify(传入对象));<br>缺点：1 事件对象转化为时间字符串而非对象<br>     2  regExp和error对象转化后得到空对象{}<br>     3 函数和undefined将直接丢失<br>     4 NaN Infinity -Infinity转化后为null<br>     5 JSON.stringify()只能序列化对象的可枚举的自有属性，如constructor构造函数会丢失<br>     6 循环引用的对象也无法拷贝</p>
<p>Object.prototype.toString.call(o)能直接返回对象的类属性，形如”[object class]”的字符串，我们通过截取class，并能知道传入的对象是什么类型<br>tips：<br>为什么不直接用toString方法？这是为了防止对象中的toString方法被重写，为了正确的调用toString()版本，必须间接的调用Function.call()方法<br>为什么不使用typeof来直接判断类型？因为对于Array而言，使用typeof（Array）返回的是object，所以不能得到正确的Array，这里对于后续的数组克隆将产生致命的问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">function istype(o)&#123;</span><br><span class="line">    if(o === null) return &apos;Null&apos;;</span><br><span class="line">    if(o === undefined) return &apos;Undefined&apos;;</span><br><span class="line">    return Object.prototype.toString.call(o).slice(8,-1);// -1代表从尾部元素算起</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">function deepClone(obj) &#123;</span><br><span class="line">    let result, type = isType(obj);</span><br><span class="line">    if(type === &apos;Array&apos;) &#123;</span><br><span class="line">        result = [];</span><br><span class="line">    &#125;else if(type === &apos;Object&apos;)&#123;</span><br><span class="line">        result = &#123;&#125;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br><span class="line">    for(let key in obj) &#123;</span><br><span class="line">        let copy = obj[key];</span><br><span class="line">        let childType = isType(copy);</span><br><span class="line">        if(childType === &apos;Array&apos; || childType === &apos;Object&apos;) &#123;</span><br><span class="line">            // result[key] = deepClone(copy);</span><br><span class="line">            result[key] = arguments.callee(copy);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            result[key] = copy;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="promise-的es5实现"><a href="#promise-的es5实现" class="headerlink" title="promise 的es5实现"></a>promise 的es5实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">function Mypromise(fn)&#123;</span><br><span class="line">    this.value;</span><br><span class="line">    this.status = &apos;pending&apos;;</span><br><span class="line">    this.resolveFunc = function()P&#123;&#125;;</span><br><span class="line">    this.rejectFunc = function()&#123;&#125;;</span><br><span class="line">    fn(this.resolve.bind(this),this.reject.bind(this));</span><br><span class="line">&#125;</span><br><span class="line">Mypromise.prototype.resolve = function(val)&#123;</span><br><span class="line">    var self = this;</span><br><span class="line">    if(this.status === &apos;pending&apos;)&#123;</span><br><span class="line">        self.status = &apos;resolved&apos;;</span><br><span class="line">        self.value = val;</span><br><span class="line">        setTimeout(function()&#123;</span><br><span class="line">            self.resolveFun(self.value);</span><br><span class="line">        &#125;,0)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Mypromise.prototype.reject = function(val)&#123;</span><br><span class="line">    var self = this;</span><br><span class="line">    if(this.status === &apos;pending&apos;)&#123;</span><br><span class="line">        self.status = &apos;rejected&apos;;</span><br><span class="line">        self.value = val;</span><br><span class="line">        setTimeout(function()&#123;</span><br><span class="line">           self.rejectFun(self.value);</span><br><span class="line">        &#125;,0)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// </span><br><span class="line">Mypromise.prototype.then = function(resolveFun,rejectFunc)&#123;</span><br><span class="line">    this.resolveFunc = resolveFunc;</span><br><span class="line">    this.rejectFun = rejectFunc;</span><br><span class="line">&#125;</span><br><span class="line">var fn = function(resove,reject)&#123;</span><br><span class="line">    var num = Math.random();</span><br><span class="line">    if(num&gt;0.5)&#123;</span><br><span class="line">        resolve(&apos;more then 0.5&apos;)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        reject(&apos;less then 0.5&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var p = new Mypromise(fn).then(function(data)&#123;</span><br><span class="line">    console.log(data);</span><br><span class="line">&#125;,function(data)&#123;</span><br><span class="line">    console.log(data)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 完善then方法 链式调用</span><br><span class="line">Mypromise.prototype.then = function(resolveFun,rejectFunc)&#123;</span><br><span class="line">    var self = this;</span><br><span class="line">    return new Mypromise(function(resolve_next,rejecr_next)&#123;</span><br><span class="line">        function resolveFunWrap()&#123;</span><br><span class="line">            var result = resolveFun(self.value);</span><br><span class="line">            if(result &amp;&amp; result.then)&#123; // Mypromise对象</span><br><span class="line">                result.then(resolve_next,rejecr_next)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                resolve_next(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        function rejectFunWrap()&#123;</span><br><span class="line">            var result = rejectFun(self.value);</span><br><span class="line">            if(result &amp;&amp; result.then)&#123; // Mypromise对象</span><br><span class="line">                result.then(resolve_next,rejecr_next)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                reject_next(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        self.resolveFunc = resolveFunWrap;</span><br><span class="line">        self.rejectFunc = rejectFunWrap;</span><br><span class="line">    &#125;)</span><br><span class="line">    this.resolveFunc = resolveFunc;</span><br><span class="line">    this.rejectFun = rejectFunc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="中间件实现"><a href="#中间件实现" class="headerlink" title="中间件实现"></a>中间件实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// 简洁版（同步）</span><br><span class="line">function fn1()&#123;</span><br><span class="line">    console.log(&apos;fn1&apos;)</span><br><span class="line">&#125;</span><br><span class="line">function fn2()&#123;</span><br><span class="line">    console.log(&apos;fn2&apos;)</span><br><span class="line">&#125;</span><br><span class="line">function fn2()&#123;</span><br><span class="line">    console.log(&apos;fn2&apos;)</span><br><span class="line">&#125;</span><br><span class="line">//const pip = (fn1,fn2,fn3)=&gt;(...args)=&gt;fn3(fn2(fn1(...args)))</span><br><span class="line">// const compose1 = (fn1,fn2,fn3)=&gt;(...args)=&gt;fn1(fn2(fn3(...args)));</span><br><span class="line">// const compose = (...funcs)=&gt;(...args)=&gt;&#123;</span><br><span class="line">//    if(funcs.length===0) return args;</span><br><span class="line">//    if(funcs.length===1) return funcs[0](...args);</span><br><span class="line">//    return funcs.reduce((a,b)=&gt;(...args)=&gt;a(b(...args))) // pip:funcs.reduce((a,b)=&gt;(...args)=&gt;b(a(...args))) </span><br><span class="line">// &#125;</span><br><span class="line">const compose = (...[first,...rest])=&gt;(...args)=&gt;&#123;</span><br><span class="line">    let ret = first(...args);</span><br><span class="line">    rest.forEach(fn=&gt;&#123;</span><br><span class="line">        ret = fn(ret);</span><br><span class="line">    &#125;)</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line">// koa中间件 异步</span><br><span class="line">function compose =(middlewares)&#123;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        return dispatch(0);</span><br><span class="line">        function dispatch(i)&#123;</span><br><span class="line">            const fn = middlewares[i];</span><br><span class="line">            if(!fn)&#123;</span><br><span class="line">                return Promise.resove();</span><br><span class="line">            &#125;</span><br><span class="line">            return Promise.resolve(</span><br><span class="line">                fn(function next()&#123; </span><br><span class="line">                    retrun dispatch(i+1)；// next执行递归调用</span><br><span class="line">                &#125;)</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="手写new"><a href="#手写new" class="headerlink" title="手写new"></a>手写new</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function myNew()&#123;</span><br><span class="line">    /** 1 我们都new第一个参数为构造函数</span><br><span class="line">     * shift:把数组的第一个元素从其中删除，并返回第一个元素的值</span><br><span class="line">     * 此时Constructor就是构造函数</span><br><span class="line">     */</span><br><span class="line">    let Constructor = Array.prototype.shift.call(arguments);</span><br><span class="line">    /** 2 将要返回的实例 */</span><br><span class="line">    let obj = &#123;&#125;;</span><br><span class="line">    /** 3 实例obj和构造函数Constructor指向同一个原型对象 */</span><br><span class="line">    obj.__proto__ = Constructor.prototype;</span><br><span class="line">    /** 4 拿到实例执行的结果 观察结果是不是一个引用类型</span><br><span class="line">     * 改变Constructor的this指向为将要返回的实例obj 并传递参数 </span><br><span class="line">     * 这里一定要用apply 不要用call 因为apply传递的是一个参数数组</span><br><span class="line">    */</span><br><span class="line">    let r = Constructor.apply(obj,arguments);</span><br><span class="line">    return r instanceof Constructor? r : obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Animal(type)&#123;</span><br><span class="line">    this.type = type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Animal.prototype.eat = function()&#123;</span><br><span class="line">    console.log(&apos;eat-meat&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let tiger = new Animal(&apos;tiger&apos;);</span><br><span class="line">let tiger1 = new myNew(Animal,&apos;tiger&apos;);</span><br><span class="line"></span><br><span class="line">console.log(tiger.type); // 打印 tiger</span><br><span class="line">console.log(tiger.eat()); // 打印 eat-meat</span><br><span class="line"></span><br><span class="line">console.log(tiger1.type); // 打印 tiger</span><br><span class="line">console.log(tiger1.eat()); // 打印 eat-meat</span><br></pre></td></tr></table></figure>
<h4 id="手写call"><a href="#手写call" class="headerlink" title="手写call"></a>手写call</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/* Function原型上拓展call方法*/</span><br><span class="line"></span><br><span class="line">Function.prototype.myCall = function(context)&#123;</span><br><span class="line">    /** 1 如果没传上下文conntext 就取window为this </span><br><span class="line">     * 此处Object() 主要考虑到如果是String类型</span><br><span class="line">    */</span><br><span class="line">    context = context?Object(context):window;</span><br><span class="line">    /** 2 改变this指向</span><br><span class="line">     * this就是原函数 */</span><br><span class="line">    context.fn = this;</span><br><span class="line">    /** 3 取参数 注意从第二个开始取</span><br><span class="line">     * 因为第一个参数是上下文context 也就是this</span><br><span class="line">    */</span><br><span class="line">    let args = [];</span><br><span class="line">    for(let i = 1; i &lt; arguments.length; i++)&#123;</span><br><span class="line">        /** 4 这里传递的上字符串 因为待会要配合eval()使用 */</span><br><span class="line">        args.push(&apos;arguments[&apos;+ i +&apos;]&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    /** 5 把参数传递进去 eval()方法可以让字符串执行 */</span><br><span class="line">    let r = eval(&apos;context.fn(&apos;+ args +&apos;)&apos;);</span><br><span class="line">    /** 6 删除原context.fn */</span><br><span class="line">    delete context.fn;</span><br><span class="line">    /** 7 返回r */</span><br><span class="line">    return r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let str = &apos;str&apos;;</span><br><span class="line"></span><br><span class="line">let obj = &#123;</span><br><span class="line">    name:&apos;123&apos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function fn()&#123;</span><br><span class="line">    console.log(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn.myCall(str); // 打印 String &#123;&quot;str&quot;&#125;</span><br><span class="line">fn.myCall(obj); // 打印 &#123;name: &quot;123&quot;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="手写apply"><a href="#手写apply" class="headerlink" title="手写apply"></a>手写apply</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/* Function原型上拓展apply方法*/</span><br><span class="line"></span><br><span class="line">Function.prototype.myApply = function(context,args)&#123;</span><br><span class="line">    /** 1 如果没传上下文conntext 就取window为this </span><br><span class="line">     * 此处Object() 主要考虑到如果是String类型</span><br><span class="line">    */</span><br><span class="line">    context = context?Object(context):window;</span><br><span class="line">    /** 2 改变this指向</span><br><span class="line">     * this就是原函数 */</span><br><span class="line">    context.fn = this;</span><br><span class="line">    /** 3 把参数传递进去 eval()可以让字符串执行 */</span><br><span class="line">    let r = eval(&apos;context.fn(&apos;+ args +&apos;)&apos;);</span><br><span class="line">    /** 6 删除原context.fn */</span><br><span class="line">    delete context.fn;</span><br><span class="line">    /** 7 返回r */</span><br><span class="line">    return r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let str = &apos;str&apos;;</span><br><span class="line"></span><br><span class="line">let obj = &#123;</span><br><span class="line">    name:&apos;123&apos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function fn()&#123;</span><br><span class="line">    console.log(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn.apply(str);  // 打印 String &#123;&quot;str&quot;&#125;</span><br><span class="line">fn.apply(obj); // 打印 &#123;name: &quot;123&quot;&#125;</span><br><span class="line"></span><br><span class="line">fn.myApply(str);  // 打印 String &#123;&quot;str&quot;&#125;</span><br><span class="line">fn.myApply(obj); // 打印 &#123;name: &quot;123&quot;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="compose-pipe"><a href="#compose-pipe" class="headerlink" title="compose pipe"></a>compose pipe</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">function compose(middlewares) &#123;</span><br><span class="line">  return function() &#123;</span><br><span class="line">    return dispatch(0); // 执⾏行行第0个</span><br><span class="line">    function dispatch(i) &#123;</span><br><span class="line">      let fn = middlewares[i];</span><br><span class="line">      if (!fn) &#123;</span><br><span class="line">        return Promise.resolve();</span><br><span class="line">      &#125;</span><br><span class="line">      return Promise.resolve(</span><br><span class="line">        fn(function next() &#123;</span><br><span class="line">          // promise完成后，再执⾏行行下⼀一个</span><br><span class="line">          return dispatch(i + 1);</span><br><span class="line">        &#125;)</span><br><span class="line">     ); </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="es6-async"><a href="#es6-async" class="headerlink" title="es6   async"></a>es6   async</h4>
        
      </div>
      
      
      
    </div>
    
    
    
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/touxiang.png" alt="luhu">
            
              <p class="site-author-name" itemprop="name">luhu</p>
              <p class="site-description motion-element" itemprop="description">前端日记</p>
          </div>

          <nav class="site-state motion-element">

            

            

            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/luguanghu" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:luguanghu991@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#检测对象类型的几种方式："><span class="nav-number">1.</span> <span class="nav-text">检测对象类型的几种方式：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#创建作用域安全的对象"><span class="nav-number">2.</span> <span class="nav-text">创建作用域安全的对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#惰性载入函数"><span class="nav-number">3.</span> <span class="nav-text">惰性载入函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#柯里化函数"><span class="nav-number">4.</span> <span class="nav-text">柯里化函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#定时器的应用"><span class="nav-number">5.</span> <span class="nav-text">定时器的应用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#函数节流-throttle"><span class="nav-number">6.</span> <span class="nav-text">函数节流 throttle</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#防抖函数-debonuce"><span class="nav-number">7.</span> <span class="nav-text">防抖函数 debonuce</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#自定义事件"><span class="nav-number">8.</span> <span class="nav-text">自定义事件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#异步"><span class="nav-number">9.</span> <span class="nav-text">异步</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#深度克隆"><span class="nav-number">10.</span> <span class="nav-text">深度克隆</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#promise-的es5实现"><span class="nav-number">11.</span> <span class="nav-text">promise 的es5实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#中间件实现"><span class="nav-number">12.</span> <span class="nav-text">中间件实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#手写new"><span class="nav-number">13.</span> <span class="nav-text">手写new</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#手写call"><span class="nav-number">14.</span> <span class="nav-text">手写call</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#手写apply"><span class="nav-number">15.</span> <span class="nav-text">手写apply</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#compose-pipe"><span class="nav-number">16.</span> <span class="nav-text">compose pipe</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#es6-async"><span class="nav-number">17.</span> <span class="nav-text">es6   async</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">luhu</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 搭建</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  









  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three-waves.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
